\chapter{Conclusion and future work}
The aim of this thesis was to improve Stride, a model to simulate infectious diseases, by decreasing the simulation runtime and by increasing its ease of use. In order to get a deeper understanding on this topic, we explained how infectious diseases work and what relevant mathematical and computational models exist. Then, we discussed what the philosophy is behind Stride, how it works, and what data it uses for its simulations. We analysed the model runtimes using varying number of threads for both algorithms that are used to determine the contacts and transmissions, after which we presented an optimisation to pass the shared pointer of the population by reference. The impact of the size and type of the pool on the runtime was then examined, and the reversed contact vector was introduced as an additional method to verify the correctness of an algorithm. We presented different optimisation algorithms to compute contacts and transmissions for pools, and examined the correctness and performance of each algorithm. At last, we discussed how our domain specific language, called EpiQL, can be used to abstract the use of infectious disease models.
\\\\
Passing the shared pointer of the population by reference has proven to be a major runtime optimisation for both infector algorithms. Because of this, parallellization can now also used to speed up the runtimes even more, which had the exact opposite effect at the start of this thesis. The four algorithms that we presented as optimisations for the \textsc{All-to-All} algorithm, all resulted in faster runtimes while still producing correct results. Running simulations by using our fastest algorithm (\textsc{Full-sampling (>150)}) showed to be 4.47 times faster than the simulations since the beginning. For simulations that only want to calculate transmissions, we presented one algorithm (\textsc{Iterative-intervals}) next to the pass-by-reference optimisation, which is faster than the original simulation from the start, namely 1.14 times, and still generates correct results. Thus, we conclude that we have improved the runtimes of Stride simulations.
\\\\
Parallellization still resulted in sub-optimal runtimes for other parts of the simulation, which we did not further investigate due to the limited impact it would have. These issues could be due to the way Stride is implemented, which requires extra research and a restructuring of the model. Further investigation on our optimised algorithms have been discussed, such as sorting the contact pools based on their size to minimize the overhead of branch predictions, which can result in even faster runtimes. Combining different algorithms in one simulation resulted in sub-optimal runtimes due to the extra overhead, on which additional research can be done together with the sortation of pools. We also established that pools, in which almost everyone is a member of the same age interval, reduce the performance of certain algorithms. Improvements to this can be examined by, for example, dividing those intervals into multiple smaller ones. 
\\\\
We showed how our domain specific language can be used to express how a Stride simulation should run, without the need for detailed knowledge of the model. We discussed why Rust is a suitable language to create our EpiQL compiler and what steps have been implemented. Creating our DSL turned out to be an intensive and non-trivial task, for which more extensive research is needed to complete a flawless language that incorporates our optimised algorithms. Future work on this is ensured by a new master's thesis that continues on this one.